diff --git a/node_modules/microphone-js/dist/microphone-js.cjs.development.js b/node_modules/microphone-js/dist/microphone-js.cjs.development.js
index d2e86f4..93964ff 100644
--- a/node_modules/microphone-js/dist/microphone-js.cjs.development.js
+++ b/node_modules/microphone-js/dist/microphone-js.cjs.development.js
@@ -1,23 +1,5 @@
 'use strict';
 
-function _extends() {
-  _extends = Object.assign || function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
-        }
-      }
-    }
-
-    return target;
-  };
-
-  return _extends.apply(this, arguments);
-}
-
 var flattenArray = function flattenArray(channelBuffer, recordingLength) {
   var offset = 0;
   return channelBuffer.reduce(function (acc, buffer) {
@@ -76,19 +58,21 @@ var DEFAULT_SAMPLE_RATE = 44100;
 var BUFFER_SIZE = 2048;
 var LEFT_CHAN_DATA = 0;
 var RIGHT_CHAN_DATA = 1;
-var initialState = {
-  leftChan: [],
-  rightChan: [],
-  recordingLength: 0
+
+var initialState = function initialState() {
+  return {
+    leftChan: [],
+    rightChan: [],
+    recordingLength: 0
+  };
 };
+
 var Microphone = function Microphone(instanceConfig) {
   var mediaStream;
   var source;
   var recorder;
   var blob;
-
-  var audioState = _extends({}, initialState);
-
+  var audioState = initialState();
   var isMono = !!(instanceConfig && instanceConfig.isMono);
   var nbChannels = isMono ? 1 : NB_CHANNELS;
   var sampleRate = instanceConfig && instanceConfig.sampleRate || DEFAULT_SAMPLE_RATE;
@@ -134,7 +118,7 @@ var Microphone = function Microphone(instanceConfig) {
   };
 
   var reset = function reset() {
-    audioState = _extends({}, initialState);
+    audioState = initialState();
   }; // // http://soundfile.sapp.org/doc/WaveFormat/
 
 
diff --git a/node_modules/microphone-js/dist/microphone-js.cjs.development.js.map b/node_modules/microphone-js/dist/microphone-js.cjs.development.js.map
index 1d07905..1f03a93 100644
--- a/node_modules/microphone-js/dist/microphone-js.cjs.development.js.map
+++ b/node_modules/microphone-js/dist/microphone-js.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"microphone-js.cjs.development.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState: AudioState = {\n  leftChan: [],\n  rightChan: [],\n  recordingLength: 0,\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = { ...initialState };\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = { ...initialState };\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","interleave","leftChannel","rightChannel","_","index","writeUTFBytes","view","str","split","map","charCodeAt","forEach","value","idx","setUint8","downsampleBuffer","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","NB_CHANNELS","DEFAULT_SAMPLE_RATE","BUFFER_SIZE","LEFT_CHAN_DATA","RIGHT_CHAN_DATA","initialState","leftChan","rightChan","Microphone","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","reset","encodeWav","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","stop","getTracks","track","disconnect","leftChanData","rightChanData","array","downsampled","download","getBlob","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"microphone-js.cjs.development.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState = () : AudioState => {\n    return {    \n      leftChan: [],\n      rightChan: [],\n      recordingLength: 0,\n    }\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = initialState();\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = initialState();\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","interleave","leftChannel","rightChannel","_","index","writeUTFBytes","view","str","split","map","charCodeAt","forEach","value","idx","setUint8","downsampleBuffer","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","NB_CHANNELS","DEFAULT_SAMPLE_RATE","BUFFER_SIZE","LEFT_CHAN_DATA","RIGHT_CHAN_DATA","initialState","leftChan","rightChan","Microphone","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","reset","encodeWav","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","stop","getTracks","track","disconnect","leftChanData","rightChanData","array","downsampled","download","getBlob","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js b/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js
index da10f02..107af73 100644
--- a/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js
+++ b/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}var e=function(t,e){var n=0;return t.reduce(function(t,e){return t.set(e,n),n+=e.length,t},new Float32Array(e))},n=function(t,e,n){n.split("").map(function(t,e){return n.charCodeAt(e)}).forEach(function(n,r){t.setUint8(e+r,n)})},r={leftChan:[],rightChan:[],recordingLength:0};exports.Microphone=function(a){var o,i,c,u,s=t({},r),f=!(!a||!a.isMono),h=f?1:2,l=a&&a.sampleRate||44100,d={nbChannels:h,sampleRate:l,bufferSize:2048,byteRate:l*h*2},g=function(){return u};return{start:function(){try{return Promise.resolve(navigator.mediaDevices.getUserMedia({audio:!0,video:!1})).then(function(t){o=t;var e=new AudioContext,n=e.createGain();i=e.createMediaStreamSource(o),(c=e.createScriptProcessor(d.bufferSize,2,2)).onaudioprocess=function(t){var e=new Float32Array(t.inputBuffer.getChannelData(0));s.leftChan.push(e),s.rightChan.push(new Float32Array(t.inputBuffer.getChannelData(1))),s.recordingLength+=d.bufferSize,a&&a.onData&&a.onData(e)},i.connect(n),i.connect(c),c.connect(e.destination)})}catch(t){return Promise.reject(t)}},stop:function(){o&&o.getTracks().forEach(function(t){return t.stop()}),c&&c.disconnect(),i&&i.disconnect();var t,r=e(s.leftChan,s.recordingLength),a=e(s.rightChan,s.recordingLength),h=function(t,e,n){if(44100===n)return t;for(var r=44100/n,a=Math.round(t.length/r),o=new Float32Array(a),i=0,c=0;i<o.length;){for(var u=Math.round((i+1)*r),s=0,f=0,h=c;h<u&&h<t.length;h++)s+=t[h],f++;o[i]=s/f,i++,c=u}return o}(f?r:(t=r).reduce(function(e,n,r){var a=2*r;return e[a]=t[r],e[a+1]=t[r],e},new Float32Array(t.length+a.length)),0,d.sampleRate);u=function(t){var e=new ArrayBuffer(44+2*t.length),r=new DataView(e);n(r,0,"RIFF"),r.setUint32(4,44+2*t.length,!0),n(r,8,"WAVE"),n(r,12,"fmt "),r.setUint32(16,16,!0),r.setUint16(20,1,!0),r.setUint16(22,d.nbChannels,!0),r.setUint32(24,d.sampleRate,!0),r.setUint32(28,d.byteRate,!0),r.setUint16(32,4,!0),r.setUint16(34,16,!0),n(r,36,"data"),r.setUint32(40,2*t.length,!0);for(var a=0;a<t.length;a++)r.setInt16(44+2*a,32767*t[a],!0);return new Blob([r],{type:"audio/wav"})}(h)},reset:function(){s=t({},r)},download:function(){var t=g();if(t&&window&&document&&URL){var e=URL.createObjectURL(t),n=document.createElement("a");document.body.appendChild(n),n.href=e,n.download=(new Date).toISOString()+".wav",n.click(),window.URL.revokeObjectURL(e)}},getBlob:g}};
+"use strict";var e=function(e,t){var n=0;return e.reduce(function(e,t){return e.set(t,n),n+=t.length,e},new Float32Array(t))},t=function(e,t,n){n.split("").map(function(e,t){return n.charCodeAt(t)}).forEach(function(n,r){e.setUint8(t+r,n)})};exports.Microphone=function(n){var r,a,o,i,c={leftChan:[],rightChan:[],recordingLength:0},u=!(!n||!n.isMono),h=u?1:2,f=n&&n.sampleRate||44100,s={nbChannels:h,sampleRate:f,bufferSize:2048,byteRate:f*h*2},l=function(){return i};return{start:function(){try{return Promise.resolve(navigator.mediaDevices.getUserMedia({audio:!0,video:!1})).then(function(e){r=e;var t=new AudioContext,i=t.createGain();a=t.createMediaStreamSource(r),(o=t.createScriptProcessor(s.bufferSize,2,2)).onaudioprocess=function(e){var t=new Float32Array(e.inputBuffer.getChannelData(0));c.leftChan.push(t),c.rightChan.push(new Float32Array(e.inputBuffer.getChannelData(1))),c.recordingLength+=s.bufferSize,n&&n.onData&&n.onData(t)},a.connect(i),a.connect(o),o.connect(t.destination)})}catch(e){return Promise.reject(e)}},stop:function(){r&&r.getTracks().forEach(function(e){return e.stop()}),o&&o.disconnect(),a&&a.disconnect();var n,h=e(c.leftChan,c.recordingLength),f=e(c.rightChan,c.recordingLength),l=function(e,t,n){if(44100===n)return e;for(var r=44100/n,a=Math.round(e.length/r),o=new Float32Array(a),i=0,c=0;i<o.length;){for(var u=Math.round((i+1)*r),h=0,f=0,s=c;s<u&&s<e.length;s++)h+=e[s],f++;o[i]=h/f,i++,c=u}return o}(u?h:(n=h).reduce(function(e,t,r){var a=2*r;return e[a]=n[r],e[a+1]=n[r],e},new Float32Array(n.length+f.length)),0,s.sampleRate);i=function(e){var n=new ArrayBuffer(44+2*e.length),r=new DataView(n);t(r,0,"RIFF"),r.setUint32(4,44+2*e.length,!0),t(r,8,"WAVE"),t(r,12,"fmt "),r.setUint32(16,16,!0),r.setUint16(20,1,!0),r.setUint16(22,s.nbChannels,!0),r.setUint32(24,s.sampleRate,!0),r.setUint32(28,s.byteRate,!0),r.setUint16(32,4,!0),r.setUint16(34,16,!0),t(r,36,"data"),r.setUint32(40,2*e.length,!0);for(var a=0;a<e.length;a++)r.setInt16(44+2*a,32767*e[a],!0);return new Blob([r],{type:"audio/wav"})}(l)},reset:function(){c={leftChan:[],rightChan:[],recordingLength:0}},download:function(){var e=l();if(e&&window&&document&&URL){var t=URL.createObjectURL(e),n=document.createElement("a");document.body.appendChild(n),n.href=t,n.download=(new Date).toISOString()+".wav",n.click(),window.URL.revokeObjectURL(t)}},getBlob:l}};
 //# sourceMappingURL=microphone-js.cjs.production.min.js.map
diff --git a/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js.map b/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js.map
index 2880df6..451e14e 100644
--- a/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js.map
+++ b/node_modules/microphone-js/dist/microphone-js.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"microphone-js.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState: AudioState = {\n  leftChan: [],\n  rightChan: [],\n  recordingLength: 0,\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = { ...initialState };\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = { ...initialState };\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","writeUTFBytes","view","str","split","map","_","index","charCodeAt","forEach","value","idx","setUint8","initialState","leftChan","rightChan","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","getBlob","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","stop","getTracks","track","disconnect","leftChannel","leftChanData","rightChanData","downsampled","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","downsampleBuffer","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","encodeWav","reset","download","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"microphone-js.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState = () : AudioState => {\n    return {    \n      leftChan: [],\n      rightChan: [],\n      recordingLength: 0,\n    }\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = initialState();\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = initialState();\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","writeUTFBytes","view","str","split","map","_","index","charCodeAt","forEach","value","idx","setUint8","instanceConfig","mediaStream","source","recorder","blob","audioState","leftChan","rightChan","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","getBlob","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","stop","getTracks","track","disconnect","leftChannel","leftChanData","rightChanData","downsampled","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","downsampleBuffer","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","encodeWav","reset","download","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/microphone-js/dist/microphone-js.esm.js b/node_modules/microphone-js/dist/microphone-js.esm.js
index c51847b..7249109 100644
--- a/node_modules/microphone-js/dist/microphone-js.esm.js
+++ b/node_modules/microphone-js/dist/microphone-js.esm.js
@@ -1,21 +1,3 @@
-function _extends() {
-  _extends = Object.assign || function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
-        }
-      }
-    }
-
-    return target;
-  };
-
-  return _extends.apply(this, arguments);
-}
-
 var flattenArray = function flattenArray(channelBuffer, recordingLength) {
   var offset = 0;
   return channelBuffer.reduce(function (acc, buffer) {
@@ -74,19 +56,21 @@ var DEFAULT_SAMPLE_RATE = 44100;
 var BUFFER_SIZE = 2048;
 var LEFT_CHAN_DATA = 0;
 var RIGHT_CHAN_DATA = 1;
-var initialState = {
-  leftChan: [],
-  rightChan: [],
-  recordingLength: 0
+
+var initialState = function initialState() {
+  return {
+    leftChan: [],
+    rightChan: [],
+    recordingLength: 0
+  };
 };
+
 var Microphone = function Microphone(instanceConfig) {
   var mediaStream;
   var source;
   var recorder;
   var blob;
-
-  var audioState = _extends({}, initialState);
-
+  var audioState = initialState();
   var isMono = !!(instanceConfig && instanceConfig.isMono);
   var nbChannels = isMono ? 1 : NB_CHANNELS;
   var sampleRate = instanceConfig && instanceConfig.sampleRate || DEFAULT_SAMPLE_RATE;
@@ -132,7 +116,7 @@ var Microphone = function Microphone(instanceConfig) {
   };
 
   var reset = function reset() {
-    audioState = _extends({}, initialState);
+    audioState = initialState();
   }; // // http://soundfile.sapp.org/doc/WaveFormat/
 
 
diff --git a/node_modules/microphone-js/dist/microphone-js.esm.js.map b/node_modules/microphone-js/dist/microphone-js.esm.js.map
index 38f8be7..7476289 100644
--- a/node_modules/microphone-js/dist/microphone-js.esm.js.map
+++ b/node_modules/microphone-js/dist/microphone-js.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"microphone-js.esm.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState: AudioState = {\n  leftChan: [],\n  rightChan: [],\n  recordingLength: 0,\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = { ...initialState };\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = { ...initialState };\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","interleave","leftChannel","rightChannel","_","index","writeUTFBytes","view","str","split","map","charCodeAt","forEach","value","idx","setUint8","downsampleBuffer","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","NB_CHANNELS","DEFAULT_SAMPLE_RATE","BUFFER_SIZE","LEFT_CHAN_DATA","RIGHT_CHAN_DATA","initialState","leftChan","rightChan","Microphone","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","reset","encodeWav","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","stop","getTracks","track","disconnect","leftChanData","rightChanData","array","downsampled","download","getBlob","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"microphone-js.esm.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const flattenArray = (\n  channelBuffer: Float32Array[],\n  recordingLength: number\n): Float32Array => {\n  let offset = 0;\n\n  return channelBuffer.reduce((acc, buffer) => {\n    acc.set(buffer, offset);\n    offset += buffer.length;\n    return acc;\n  }, new Float32Array(recordingLength));\n};\n\nexport const interleave = (\n  leftChannel: Float32Array,\n  rightChannel: Float32Array\n) => {\n  const length = leftChannel.length + rightChannel.length;\n\n  return leftChannel.reduce((acc, _, index) => {\n    const offset = index * 2;\n\n    acc[offset] = leftChannel[index];\n    acc[offset + 1] = leftChannel[index];\n    return acc;\n  }, new Float32Array(length));\n};\n\nexport const writeUTFBytes = (\n  view: DataView,\n  offset: number,\n  str: string\n): any => {\n  str\n    .split('')\n    .map((_, index) => str.charCodeAt(index))\n    .forEach((value, idx) => {\n      view.setUint8(offset + idx, value);\n    });\n};\n\nexport const downsampleBuffer = (\n  buffer: Float32Array,\n  currentSampleRate: number,\n  targetSampleRate: number\n) => {\n  if (targetSampleRate === currentSampleRate) {\n    return buffer;\n  }\n  var sampleRateRatio = currentSampleRate / targetSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Float32Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n      count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = accum / count;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result;\n};\n","import './types';\n\nimport {\n  writeUTFBytes,\n  flattenArray,\n  interleave,\n  downsampleBuffer,\n} from './utils';\n\nconst NB_CHANNELS = 2;\nconst DEFAULT_SAMPLE_RATE = 44100;\nconst BUFFER_SIZE = 2048;\nconst LEFT_CHAN_DATA = 0;\nconst RIGHT_CHAN_DATA = 1;\n\nconst initialState = () : AudioState => {\n    return {    \n      leftChan: [],\n      rightChan: [],\n      recordingLength: 0,\n    }\n};\n\nexport const Microphone = (\n  instanceConfig?: InstanceConfig\n): MicrophoneInstance => {\n  let mediaStream: MediaStream | undefined;\n  let source: MediaStreamAudioSourceNode | undefined;\n  let recorder: ScriptProcessorNode | undefined;\n  let blob: Blob | undefined;\n  let audioState: AudioState = initialState();\n\n  const isMono: boolean = !!(instanceConfig && instanceConfig.isMono);\n\n  const nbChannels: number = isMono ? 1 : NB_CHANNELS;\n\n  const sampleRate =\n    (instanceConfig && instanceConfig.sampleRate) || DEFAULT_SAMPLE_RATE;\n\n  const config: Config = {\n    nbChannels,\n    sampleRate,\n    bufferSize: BUFFER_SIZE,\n    byteRate: sampleRate * nbChannels * 2,\n  };\n\n  const start = async () => {\n    mediaStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    const audioCtx = new AudioContext();\n    const volume = audioCtx.createGain();\n    source = audioCtx.createMediaStreamSource(mediaStream);\n\n    const numberOfInputChannels = 2;\n    const numberOfOutputChannels = 2;\n\n    recorder = audioCtx.createScriptProcessor(\n      config.bufferSize,\n      numberOfInputChannels,\n      numberOfOutputChannels\n    );\n\n    recorder.onaudioprocess = (event: AudioProcessingEvent) => {\n      const left: Float32Array = new Float32Array(\n        event.inputBuffer.getChannelData(LEFT_CHAN_DATA)\n      );\n\n      audioState.leftChan.push(left);\n\n      audioState.rightChan.push(\n        new Float32Array(event.inputBuffer.getChannelData(RIGHT_CHAN_DATA))\n      );\n\n      audioState.recordingLength += config.bufferSize;\n\n      if (instanceConfig && instanceConfig.onData) {\n        instanceConfig.onData(left);\n      }\n    };\n\n    source.connect(volume);\n    source.connect(recorder);\n    recorder.connect(audioCtx.destination);\n  };\n\n  const reset = () => {\n    audioState = initialState();\n  };\n\n  // // http://soundfile.sapp.org/doc/WaveFormat/\n  const encodeWav = (data: Float32Array): Blob => {\n    const arrayBuffer = new ArrayBuffer(44 + data.length * 2);\n    const view = new DataView(arrayBuffer);\n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 44 + data.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE');\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, config.nbChannels, true);\n    view.setUint32(24, config.sampleRate, true);\n    view.setUint32(28, config.byteRate, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, data.length * 2, true);\n\n    for (let i = 0; i < data.length; i++) {\n      view.setInt16(44 + i * 2, (data[i] as any) * 0x7fff, true);\n    }\n\n    return new Blob([view], { type: 'audio/wav' });\n  };\n\n  const stop = () => {\n    if (mediaStream) {\n      mediaStream\n        .getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n\n    if (recorder) {\n      recorder.disconnect();\n    }\n\n    if (source) {\n      source.disconnect();\n    }\n\n    const leftChanData = flattenArray(\n      audioState.leftChan,\n      audioState.recordingLength\n    );\n    const rightChanData = flattenArray(\n      audioState.rightChan,\n      audioState.recordingLength\n    );\n    const array = isMono\n      ? leftChanData\n      : interleave(leftChanData, rightChanData);\n\n    const downsampled: Float32Array = downsampleBuffer(\n      array,\n      DEFAULT_SAMPLE_RATE,\n      config.sampleRate\n    );\n\n    blob = encodeWav(downsampled);\n  };\n\n  const download = () => {\n    const blob = getBlob();\n\n    if (!blob || !window || !document || !URL) {\n      return;\n    }\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.download = `${new Date().toISOString()}.wav`;\n    a.click();\n    window.URL.revokeObjectURL(url);\n  };\n\n  const getBlob = () => blob;\n\n  return {\n    start,\n    stop,\n    reset,\n    download,\n    getBlob,\n  };\n};\n"],"names":["flattenArray","channelBuffer","recordingLength","offset","reduce","acc","buffer","set","length","Float32Array","interleave","leftChannel","rightChannel","_","index","writeUTFBytes","view","str","split","map","charCodeAt","forEach","value","idx","setUint8","downsampleBuffer","currentSampleRate","targetSampleRate","sampleRateRatio","newLength","Math","round","result","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","NB_CHANNELS","DEFAULT_SAMPLE_RATE","BUFFER_SIZE","LEFT_CHAN_DATA","RIGHT_CHAN_DATA","initialState","leftChan","rightChan","Microphone","instanceConfig","mediaStream","source","recorder","blob","audioState","isMono","nbChannels","sampleRate","config","bufferSize","byteRate","start","navigator","mediaDevices","getUserMedia","audio","video","audioCtx","AudioContext","volume","createGain","createMediaStreamSource","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","onaudioprocess","event","left","inputBuffer","getChannelData","push","onData","connect","destination","reset","encodeWav","data","arrayBuffer","ArrayBuffer","DataView","setUint32","setUint16","setInt16","Blob","type","stop","getTracks","track","disconnect","leftChanData","rightChanData","array","downsampled","download","getBlob","window","document","URL","url","createObjectURL","a","createElement","body","appendChild","href","Date","toISOString","click","revokeObjectURL"],"mappings":"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"}
\ No newline at end of file
